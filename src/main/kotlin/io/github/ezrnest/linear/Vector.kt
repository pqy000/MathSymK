package io.github.ezrnest.linear

import io.github.ezrnest.structure.*


interface GenVector<T> : GenTuple<T> {
    // added for special treatment of row vectors
    /**
     * Gets the `i`-th element in the generic vector.
     */
    operator fun get(i: Int): T

    /**
     * Returns a list containing all the elements in this generic vector in order.
     */
    fun toList(): List<T> {
        return indices.map { get(it) }
    }

    override fun flattenToList(): List<T> {
        return toList()
    }

    override fun <S> map(mapping: (T) -> S): GenVector<S>
}

/**
 * Gets the indices of this generic vector.
 */
inline val GenVector<*>.indices: IntRange
    get() = 0..<size

/**
 * Describes a mathematical vector of type `T`.
 *
 * This interface provides basic operations for vectors, such as addition, subtraction, scalar multiplication, and inner product.
 *
 *
 * By default, all the vectors are treated as column vectors.
 *
 * @author Ezrnest
 * @see Matrix
 */
interface Vector<T> : GenVector<T> {
    /*
    Created by Ezrnest at 2024/09/04 15:33
    */


    override fun <S> map(mapping: (T) -> S): Vector<S> {
        return VectorImpl.apply1(this, mapping)
    }

    companion object {

        /**
         * Creates a new vector with the given [size] with data generated by the [init].
         *
         * The [init] function will be called with the index of the element, and the return value will be the value of the element.
         *
         * @param size the size of the vector
         */
        operator fun <T> invoke(size: Int, init: (Int) -> T): MutableVector<T> {
            require(size > 0)
            return AVector.of(size, init)
        }

        operator fun <T> invoke(vararg data: T): MutableVector<T> {
            return of(data.asList())
        }

        /**
         * Creates a new vector from a list of [data].
         */
        fun <T> of(data: List<T>): MutableVector<T> {
            return AVector(data.size) { k -> data[k] }
        }

        /**
         * Creates a new vector with the given [data].
         */
        fun <T> of(vararg data: T): MutableVector<T> {
            return of(data.asList())
        }

        /**
         * Creates a new vector with the given [data].
         */
        fun <T> vec(vararg data: T): MutableVector<T> {
            return of(data.asList())
        }

        fun <T> zero(size: Int, model: AddMonoid<T>): MutableVector<T> {
            return VectorImpl.zero(size, model)
        }

        fun <T> constant(size: Int, value: T): MutableVector<T> {
            return VectorImpl.constant(size, value)
        }

        fun <T> sum(model: AddMonoid<T>, vs: List<Vector<T>>): Vector<T> {
            require(vs.isNotEmpty())
            val size = vs[0].size
            return VectorImpl.sum(vs, size, model)
        }

        fun <T> sum(model: AddMonoid<T>, vararg vs: Vector<T>): Vector<T> {
            return sum(model, vs.asList())
        }

        fun <T> sumWeighted(model: Ring<T>, weights: List<T>, elements: List<Vector<T>>): Vector<T> {
            require(weights.size == elements.size)
            return VectorImpl.sumWeighted(weights, elements, elements[0].size, model)
        }

        /**
         * Gets a unit vector with the given [length] with the [index] element being `1` and all other elements being `0`.
         */
        fun <T> unitVector(length: Int, index: Int, model: UnitRing<T>): Vector<T> {
            require(index in 0..<length)
            return zero(length, model).also { it[index] = model.one }
        }

        /**
         * Returns the list of unit vectors of the given [length] with the given [model].
         */
        fun <T> unitVectors(length: Int, model: UnitRing<T>): List<Vector<T>> {
            return (0 until length).map { i -> unitVector(length, i, model) }
        }


        fun <T> space(field: Field<T>, length: Int): StandardVectorSpace<T> {
            return StandardVectorSpace(length, field)
        }

        fun <T> over(reals: Reals<T>, length: Int): VecOverReals<T> {
            return VecOverRealsImpl(length, reals)
        }

        fun <T> over(field: Field<T>, length: Int): VecOverField<T> {
            return VecOverFieldImpl(length, field)
        }

        fun <T> over(ring: Ring<T>, length: Int): VecOverRing<T> {
            return VecOverRingImpl(length, ring)
        }

        fun <T> over(group: AddGroup<T>, length: Int): VecOverAGroup<T> {
            return VecOverAGroupImpl(length, group)
        }

        fun <T> over(monoid: AddMonoid<T>, length: Int): VecOverAMonoid<T> {
            return VecOverAMonoidImpl(length, monoid)
        }
    }
}

fun <T> Vector<T>.isSameSize(other: Vector<T>): Boolean = (size == other.size)


interface MutableVector<T> : Vector<T> {
    operator fun set(i: Int, value: T)

    fun copy(): MutableVector<T> {
        return VectorImpl.copyOf(this)
    }


    companion object {

        fun <T> of(size: Int, init: (Int) -> T): MutableVector<T> {
            return AVector.of(size, init)
        }

        fun <T> zero(size: Int, model: AddMonoid<T>): MutableVector<T> {
            return VectorImpl.zero(size, model)
        }

        fun <T> constant(size: Int, value: T): MutableVector<T> {
            return VectorImpl.constant(size, value)
        }

        fun <T> copyOf(x: Vector<T>): MutableVector<T> {
            return VectorImpl.copyOf(x)
        }
    }

}

inline fun <T> MutableVector<T>.transform(f: (T) -> T) {
    for (i in indices) {
        this[i] = f(this[i])
    }
}

@ConsistentCopyVisibility
data class AVector<T> internal constructor(
    val data: Array<Any?>
) : MutableVector<T> {
    init {
        require(data.isNotEmpty())
    }

    override val size: Int
        get() = data.size

    override fun get(i: Int): T {
        @Suppress("UNCHECKED_CAST")
        return data[i] as T
    }

    override fun set(i: Int, value: T) {
        data[i] = value
    }

    @Suppress("UNCHECKED_CAST")
    override fun toList(): List<T> {
        return data.map { it as T }
    }

    @Suppress("UNCHECKED_CAST")
    override fun elementSequence(): Sequence<T> {
        return data.asSequence().map { it as T }
    }


    override fun copy(): AVector<T> {
        return AVector(data.copyOf())
    }

    override fun toString(): String {
        return data.joinToString(prefix = "[", postfix = "]")
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AVector<*>

        if (!data.contentEquals(other.data)) return false

        return true
    }

    override fun hashCode(): Int {
        return data.contentHashCode()
    }

    companion object {

        internal inline operator fun <T> invoke(size: Int, init: (Int) -> T): AVector<T> {
            val data = Array<Any?>(size) { k -> init(k) }
            return AVector(data)
        }

        fun <T> of(size: Int, init: (Int) -> T): AVector<T> {
            return AVector(size, init)
        }
    }
}

object VectorImpl {

    private inline fun <T> apply2(
        x: Vector<T>, y: Vector<T>, f: (T, T) -> T
    ): AVector<T> {
        require(x.isSameSize(y))
        return AVector(x.size) { k -> f(x[k], y[k]) }
    }

    internal inline fun <T, N> apply1(x: Vector<T>, f: (T) -> N): AVector<N> {
        return AVector(x.size) { k -> f(x[k]) }
    }

    internal inline fun <T> apply1Inplace(x: MutableVector<T>, f: (T, Int) -> T) {
        for (i in x.indices) {
            x[i] = f(x[i], i)
        }
    }

    fun <T> copyOf(x: Vector<T>): AVector<T> {
        return apply1(x) { it }
    }

    fun <T> constant(size: Int, value: T): AVector<T> {
        return AVector(size) { value }
    }

    fun <T> zero(size: Int, model: AddMonoid<T>): AVector<T> {
        return constant(size, model.zero)
    }

    fun <T> isEqual(x: Vector<T>, y: Vector<T>, model: EqualPredicate<T>): Boolean {
        require(x.isSameSize(y))
        return x.indices.all { model.isEqual(x[it], y[it]) }
    }

    fun <T> add(x: Vector<T>, y: Vector<T>, model: AddSemigroup<T>): AVector<T> {
        return apply2(x, y, model::add)
    }

    fun <T> addAssign(x: MutableVector<T>, y: Vector<T>, model: AddSemigroup<T>) {
        apply1Inplace(x) { t, i -> model.add(t, y[i]) }
    }

    fun <T> minusAssign(x: MutableVector<T>, y: Vector<T>, model: AddGroup<T>) {
        apply1Inplace(x) { t, i -> model.subtract(t, y[i]) }
    }

    fun <T> subtract(x: Vector<T>, y: Vector<T>, model: AddGroup<T>): AVector<T> {
        return apply2(x, y, model::subtract)
    }

    fun <T> negate(x: Vector<T>, model: AddGroup<T>): AVector<T> {
        return apply1(x, model::negate)
    }

    fun <T> multiply(x: Vector<T>, k: T, model: MulSemigroup<T>): AVector<T> {
        return apply1(x) { model.multiply(k, it) }
    }

    fun <T> multiplyLong(x: Vector<T>, k: Long, model: AddGroup<T>): AVector<T> {
        return apply1(x) { model.multiplyLong(it, k) }
    }

    fun <T> divide(x: Vector<T>, k: T, model: MulGroup<T>): AVector<T> {
        return apply1(x) { model.divide(it, k) }
    }

    fun <T> sum(vs: List<Vector<T>>, size: Int, model: AddMonoid<T>): AVector<T> {
        require(vs.all { it.size == size }) { "Size mismatch! " }
        val res = zero(size, model)
        for (v in vs) {
            require(v.size == size)
            addAssign(res, v, model)
        }
        return res
    }

    fun <T> sumWeighted(weights: List<T>, elements: List<Vector<T>>, size: Int, model: Ring<T>): AVector<T> {
        require(weights.size == elements.size)
        val res = zero(size, model)
        for (i in elements.indices) {
            val k = weights[i]
            val v = elements[i]
            require(v.size == size)
            apply1Inplace(res) { t, j -> model.eval { t + k * v[j] } }
        }
        return res
    }

    fun <T> inner(x: Vector<T>, y: Vector<T>, model: Ring<T>): T {
        require(x.isSameSize(y))
        return x.indices.fold(model.zero) { acc, i -> model.eval { acc + x[i] * y[i] } }
    }

    fun <T> odot(x: Vector<T>, y: Vector<T>, model: MulSemigroup<T>): AVector<T> {
        require(x.isSameSize(y))
        return apply2(x, y, model::multiply)
    }


    fun <T> normSq(x: Vector<T>, model: Ring<T>): T {
        return inner(x, x, model)
    }

    fun <T> norm(x: Vector<T>, model: Reals<T>): T {
        return model.sqrt(normSq(x, model))
    }

    fun <T> unitize(x: Vector<T>, model: Reals<T>): AVector<T> {
        val n = norm(x, model)
        return apply1(x) { model.divide(it, n) }
    }
}

/**
 * A wrapper class for a row vector.
 */
@JvmRecord
data class RowVector<T>(val v: Vector<T>) : GenVector<T> {
    override val size: Int
        get() = v.size

    override fun elementSequence(): Sequence<T> {
        return v.elementSequence()
    }

    override fun get(i: Int): T {
        return v[i]
    }

    override fun toList(): List<T> {
        return v.toList()
    }

    override fun <S> map(mapping: (T) -> S): RowVector<S> {
        return RowVector(v.map(mapping))
    }
}

/**
 * Returns a row vector view of this vector.
 *
 * This method enables writing codes such as `v.T * A * v`, where `A` is a matrix.
 */
val <T> Vector<T>.T: RowVector<T> get() = RowVector(this)


interface VecOverEqualPredicate<T> : EqualPredicate<Vector<T>> {
    val model: EqualPredicate<T>

    override fun isEqual(x: Vector<T>, y: Vector<T>): Boolean {
        return VectorImpl.isEqual(x, y, model)
    }

}

interface VecOverASemigroup<T> : VecOverEqualPredicate<T>, AddSemigroup<Vector<T>> {
    override val model: AddSemigroup<T>

    override fun add(x: Vector<T>, y: Vector<T>): Vector<T> {
        return VectorImpl.add(x, y, model)
    }

    operator fun MutableVector<T>.plusAssign(y: Vector<T>) {
        VectorImpl.addAssign(this, y, model)
    }

    override fun contains(x: Vector<T>): Boolean {
        return x.indices.all { model.contains(x[it]) }
    }
}

interface VecOverAMonoid<T> : VecOverASemigroup<T>, AddMonoid<Vector<T>> {
    override val model: AddMonoid<T>

    val vectorLength: Int

    override val zero: Vector<T>
        get() = Vector.zero(vectorLength, model)

    override fun sum(elements: List<Vector<T>>): Vector<T> {
        return VectorImpl.sum(elements, elements[0].size, model)
    }
}

interface VecOverAGroup<T> : VecOverAMonoid<T>, AddGroup<Vector<T>> {
    override val model: AddGroup<T>

    override fun negate(x: Vector<T>): Vector<T> {
        return VectorImpl.negate(x, model)
    }

    operator fun MutableVector<T>.minusAssign(y: Vector<T>) {
        VectorImpl.minusAssign(this, y, model)
    }
}

interface VecOverRing<T> : VecOverAGroup<T>, Module<T, Vector<T>> {
    override val model: Ring<T>

    override val scalars: Ring<T>
        get() = model

    override val zero: Vector<T>
        get() = Vector.zero(vectorLength, model)

    fun hadamard(x: Vector<T>, y: Vector<T>): Vector<T> {
        return VectorImpl.odot(x, y, model)
    }

    infix fun Vector<T>.odot(y: Vector<T>): Vector<T> {
        return VectorImpl.odot(this, y, model)
    }

    fun inner(u: Vector<T>, v: Vector<T>): T {
        return VectorImpl.inner(u, v, model)
    }

    /**
     * Returns the inner (dot) product of this vector and the given vector: `⟨this, v⟩`.
     */
    infix fun Vector<T>.dot(y: Vector<T>): T {
        return VectorImpl.inner(this, y, model)
    }


    override fun scalarMul(k: T, v: Vector<T>): Vector<T> {
        return VectorImpl.multiply(v, k, model)
    }

    override fun contains(x: Vector<T>): Boolean {
        return super.contains(x)
    }

    /**
     * Returns the inner (dot) product of this row vector and the given vector: `⟨this, v⟩`.
     */
    fun RowVector<T>.matmul(v: Vector<T>): T {
        return this.v dot v
    }

    /**
     * The operator function version of [matmul].
     */
    operator fun RowVector<T>.times(v: Vector<T>): T {
        return this.matmul(v)
    }

    fun Vector<T>.normSq(): T {
        return VectorImpl.normSq(this, model)
    }

    /**
     * Performs `x += k * y` in place.
     */
    fun MutableVector<T>.plusAssignTimes(k: T, y: Vector<T>) {
        val model = model
        val x = this
        for (i in indices) {
            x[i] = model.eval { x[i] + k * y[i] }
        }
    }


    /**
     * Performs `x -= k * y` in place.
     */
    fun MutableVector<T>.minusAssignTimes(k: T, y: Vector<T>) {
        val model = model
        val x = this
        for (i in indices) {
            x[i] = model.eval { x[i] - k * y[i] }
        }
    }
}


interface VecOverField<T> : VecOverRing<T> {

    override val model: Field<T>

    operator fun Vector<T>.div(k: T): Vector<T> {
        return VectorImpl.divide(this, k, model)
    }

    operator fun MutableVector<T>.divAssign(k: T) {
        val model = model as MulGroup<T>
        for (i in indices) {
            this[i] = model.divide(this[i], k)
        }
    }

}


interface VecOverReals<T> : VecOverField<T>{
    override val model: Reals<T>

    fun Vector<T>.norm(): T {
        return VectorImpl.norm(this, model)
    }

    fun Vector<T>.unitize(): Vector<T> {
        return VectorImpl.unitize(this, model)
    }
}


internal class VecOverAMonoidImpl<T>(override val vectorLength: Int, override val model: AddMonoid<T>) : VecOverAMonoid<T>

internal class VecOverAGroupImpl<T>(override val vectorLength: Int, override val model: AddGroup<T>) : VecOverAGroup<T>

internal class VecOverRingImpl<T>(override val vectorLength: Int, override val model: Ring<T>) : VecOverRing<T>

internal class VecOverFieldImpl<T>(override val vectorLength: Int, override val model: Field<T>) : VecOverField<T>

internal class VecOverRealsImpl<T>(override val vectorLength: Int, override val model: Reals<T>) : VecOverReals<T>
